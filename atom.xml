<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[らじうむ覚書]]></title>
  <link href="http://radlon.github.io/atom.xml" rel="self"/>
  <link href="http://radlon.github.io/"/>
  <updated>2014-09-15T23:49:05+09:00</updated>
  <id>http://radlon.github.io/</id>
  <author>
    <name><![CDATA[radlon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Sbrk()を読む]]></title>
    <link href="http://radlon.github.io/blog/2014/08/31/sbrk/"/>
    <updated>2014-08-31T16:57:23+09:00</updated>
    <id>http://radlon.github.io/blog/2014/08/31/sbrk</id>
    <content type="html"><![CDATA[<p>K&amp;Rのmallocでカーネルへメモリ確保を要求するのに使用しているsbrk()について、
Linuxではどのように実装されているか読んでみました。</p>

<!-- more -->


<h1>sbrk()</h1>

<p>どうやらsbrk()は外部のライブラリが実装しているようです。</p>

<p>そこで、glibcのsbrk()を読んでみたところ、sbrk()は完全にbrk()のラッパー関数として実装されていました。<br/>
sbrk()で追加するサイズ分、brk()によりbrkの位置を移動します。<br/>
（ちなみに、brk()とはbrkの位置を変更するシステムコールです。念のため)</p>

<p>リニアアドレス上のメモリは以下の図のように使用されます。</p>

<p><img src="http://radlon.github.io/images/2014_08_31/linear_address_space.png" alt="リニアアドレス空間" /></p>

<p>start_brkからbrkまでの間がbrk()およびsbrk()で管理されるメモリです。<br/>
brk()によりbrkの位置を変更することで、メモリの領域を追加、削減するわけです。</p>

<p>brkの位置は基本的にはカーネル側で管理されていますが、glibcではbrkの位置をライブラリ側でも__curbrkに保存していました。
システムコールでわざわざbrkの位置を問い合わせるコストを削減するためですかね？</p>

<h1>brk()</h1>

<p>続けてbrk()の実装を読んでみました。</p>

<p>まず、カレントプロセスのthread_info構造体のtask_struct構造体の持つmm_struct構造体を取得します。</p>

<p>mm_struct構造体はプロセスアドレス空間に関する情報を持っています。</p>

<p>mm_struct構造体は以下のようなメンバをもっています。
なんとなく名前から用途は想像がつくと思います。</p>

<ul>
<li>start_code</li>
<li>end_code</li>
<li>start_data</li>
<li>end_data</li>
<li>start_brk</li>
<li>brk</li>
<li>など(vm_area_struct構造体とかも持ってますよ)</li>
</ul>


<p>brk()ではstart_brkからbrkまでを使用中のメモリとして扱います。</p>

<p>brkをbrk()で渡したアドレスに変更します。</p>

<p>ただし、リニアアドレスの使用状況はmm_struct構造体の持つvm_area_struct構造体でも管理しています。</p>

<p>vm_area_struct構造体ではページ単位でリニアアドレスの使用区間を管理しているようです。<br/>
そのため、変更後のbrkの位置と変更前のbrkの位置が別々のページになる場合、vm_area_struct構造体の更新も行います。</p>

<p>vm_area_struct構造体は双方向リストとして構成されており、vm_startからvm_endまでを区間としています。</p>

<p>また、必要なら(mlockall()でmm->def_flagにVM_LOCKEDフラグを立てていれば)追加したアドレスに対してmlock()と同等の処理を行い追加したメモリがページアウトされることを防ぐようにします。</p>

<p>細部は飛ばしましたが、こんな感じのようです。</p>

<p>基本的にmmap()でもだいたい同じような感じの処理をしているっぽいです。<br/>
(brk()の内部処理はmmapの処理のサブセット的な処理のようです。)</p>

<p>やっぱり、メモリ確保だけでもカーネル側で結構いろいろ処理してますね。<br/>
アプリケーションを組む上では、割と誤差の範囲レベルの処理コストとはいえ、高速化を図るならカーネルにメモリをこまめに要求するようなロジックはよろしくないのがよくわかります。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[K&R Malloc解説]]></title>
    <link href="http://radlon.github.io/blog/2014/08/25/krmalloc/"/>
    <updated>2014-08-25T23:00:00+09:00</updated>
    <id>http://radlon.github.io/blog/2014/08/25/krmalloc</id>
    <content type="html"><![CDATA[<p>結構なおした。
こんなもんかなあ…</p>

<p>K&amp;Rのmallocアルゴリズムを解説します。</p>

<!-- more -->


<p>K&amp;Rとは初期のC言語を解説した書籍「プログラミング言語C」(原題:The Programing Language)のことです。</p>

<p>著者であるブライアン・カーニハン氏(Brian W. Kernighan)とデニス・リッチー氏(Dennis M. Ritchie)の頭文字をとってK&amp;Rと呼ばれています。</p>

<p>この本の第8章 UNIXシステム・インターフェースにmalloc関数の実装例が紹介されています。</p>

<h1>mallocとは</h1>

<p>malloc関数とはヒープ領域から、指定したサイズのメモリを動的に確保する関数です。</p>

<p>malloc関数で確保したメモリは対応するfree関数で解放します。</p>

<p>明示的にメモリを解放しなければ解放されることはありません。<br/>
(まあ、プロセスが終了すれば解放されますが･･･)</p>

<p>K&amp;Rで紹介されているmallocアルゴリズムは現在実用されているmallocアルゴリズムの基となったアルゴリズムなので、
ある程度考え方が共通しています。<br/>
krmallocを知っておくと他のmallocを読むときに把握しやすくなると思います。</p>

<h1>データ構造</h1>

<p>krmallocではブロック単位でメモリを管理します。<br/>
各ブロックの先頭には以下の定義のブロックヘッダを持ち、ブロックの情報を格納しています。</p>

<pre><code class="{.c}">typedef long Aling; /* long の境界に整合させる */

union header {      /* ブロックのヘッダ */
    struct {
        union header *ptr;  /* 空きリストの上なら次のブロック */
        unsigned size;      /* このブロックの大きさ */
    } s;
    Align x;                /* ブロックの整合を強制 */
};

typedef union header Header;
</code></pre>

<ul>
<li><p>ptr</p>

<p>  次のブロックへのポインタです。<br/>
  krmallocでは未使用のブロックをリング上の一方向リストで管理します。<br/>
  使用中のブロックでは使用しません。</p></li>
<li><p>size</p>

<p>  ブロックの大きさです。
  この値はバイトサイズではなく、ブロックヘッダサイズを１単位とした値とします。</p>

<p>  krmallocではブロックヘッダサイズ単位でメモリを管理しています。<br/>
  (ブロックヘッダサイズの要素を持つ配列でメモリを管理しているイメージです)</p>

<p>  そのため、malloc関数で実際に確保されるメモリサイズはブロックヘッダサイズが最小となります。<br/>
  ブロックヘッダサイズ未満のサイズをmalloc関数で確保しようとしても、ブロックヘッダサイズで確保されるのです。</p>

<p>  <img src="http://radlon.github.io/images/2014_08_25/memory_manage_image.png" alt="メモリ管理のイメージ図" /></p></li>
<li><p>x</p>

<p>  ブロックのアライメントを強制するためのメンバです。<br/>
  この値へのアクセス自体はありません。</p></li>
</ul>


<h2>フリーブロックリスト</h2>

<p>krmallocでは未使用のブロックをリング状の一方向リストとします。
(ここではこのリストをフリーブロックリストと呼ぶことにします。)</p>

<p>一方向リストとは要素が次の要素を指すことで、形成するリストのことを言います。</p>

<p>フリーブロックリストの場合はリスト最後の要素がリストの最初の要素をさすようにすることで、
リストをリング状にしています。</p>

<p>このフリーブロックリストは検索性のために、リスト内のブロックの順序はブロックのアドレス順を維持するようにします。</p>

<p><img src="http://radlon.github.io/images/2014_08_25/free_block_list.png" alt="フリーブロックリスト" /></p>

<p>また、フリーブロックは隣接しないようにします。
フリーブロックが隣接していると、ブロックヘッダー分のメモリが無駄になるし、
利用出来るフリーブロックが細切れになり、大きなメモリを確保できなくなるためです。</p>

<p>そのため、free関数呼び出しで、フリーブロックが隣接するようになりそうなら、
隣接するフリーブロックは一つのフリーブロックに結合してしまいます。</p>

<p>malloc関数が呼ばれるとこのフリーブロックリストから適当なブロックを取り出し、アドレスを返却します。
また、free関数が呼ばれると引数で指定されたアドレスが指すブロックをフリーブロックリストに追加します。</p>

<h2>アライメント</h2>

<p>ブロックヘッダのxについて、アライメントを強制するためと説明しました。<br/>
アライメントについて簡単に解説します。</p>

<p>CPUとメモリは複数本のバス(データバス)で繋がっています。メモリを読み込む場合このデータバスの本数分の範囲をパラレルに読み込みます。</p>

<p><img src="http://radlon.github.io/images/2014_08_25/cpu_databus.png" alt="CPUバス" /></p>

<p>このようにメモリを読み込むため、図の0x00000002から0x0000006に4byteの値を配置すると
CPUはメモリへ２回アクセスする必要があります。
多少メモリの空間効率が悪くなったとしても0x00000004から0x00000007に配置した方が
１度のメモリアクセスで済むので実行効率は良くなります。</p>

<p>そのため、CPUではメモリ上に値を配置する際の位置を値のサイズ毎に決めています。</p>

<p>この位置を合わせることをアライメントを合わせると良く言います。</p>

<p>CPUはCPUの仕様で定義されたアライメントに合わせてメモリ上に値が配置されていると想定して実装されているため、
アライメントが合っていないとエラーになる場合があります。<br/>
(アライメントが合っていなくても問題がないCPUもあるらしいですが、どちらにせよ実行効率が良くなるわけではないので
そういうCPUでも基本的にはアライメントを合わせた方が良いと思います。)</p>

<p>それから、C言語の構造体および共用体のアライメントはメンバのうちの最もアライメントの制限が厳しい型(サイズの最も大きい型と言って良いかも)のアライメントが適用されます。</p>

<pre><code class="{.c}">union Hoge{
    long int x;
    short int y;
};
</code></pre>

<p>上記のような共用体の場合、各メンバのサイズはxが4byte,yが2byteで、直感的には共用体のサイズは6byteとなりますが、
先の説明のようにアライメントは最も制限が厳しい型が適用されます。
ここではshort intよりもlong intの方が明らかに制限が厳しいので、long intのアライメントが適用されます。
そのため、共用体のサイズは8byteとなります。</p>

<p>malloc関数が返却するメモリはあらゆる型で使用します。
そのため、ブロックヘッダのアライメントはあらゆる型で最もアライメントの制限が厳しい型に合わせる必要があります。</p>

<p>ちなみに、ここでいう最もアライメントの制限が厳しい型というのは、プログラミング言語の言語仕様ではなく、
CPUの仕様に依存します。<br/>
(最もアライメントの制限が厳しい型はたいていCPUのデータバスのサイズ以上になります。)</p>

<p>ちなみに、このようにアライメントを合わせるため、バイトマシンではmalloc関数が返却するアドレスの下位数ビットは必ず0になります。
(32bitマシンであれば、下位2bitが0となる。)</p>

<p>glibcのmallocでは、さらにブロックサイズの調整をしてアドレスの下位3bitが必ず0になるようにしています。
そうして、glibcのmallocではこの必ず0となる3bitをフラグとして利用することで、メモリ管理に使用するメモリサイズを削減しています。
(若干やりすぎ感がありますが…)</p>

<h1>グローバル変数</h1>

<p>アルゴリズムの解説に入る前に、krmallocで使用するグローバル変数および定数について紹介します。</p>

<pre><code class="{.c}">static Header base;     /* 開始時の空きリスト */
static Header *freep = NULL;    /* 空きリストの先頭 */

#define NALLOC  1024    /* 要求する最小の単位数 */
</code></pre>

<ul>
<li><p>base</p>

<p>  size=0のブロックヘッダのみのブロックです。
  開始時のフリーブロックリストの先頭となるブロックです。</p>

<p>  プロセス開始時または全てのブロックが使用中の場合、フリーブロックリストはこのbaseブロックしか持ちません。</p></li>
<li><p>freep</p>

<p>  malloc関数で返却するブロックをフリーブロックリストから検索する際の検索開始位置を示すポインタです。<br/>
  free関数で解放するブロックに隣接するブロックの検索時の検索開始位置でもあります。</p>

<p>  malloc関数呼び出し時は、処理終了時に返却するブロックの直前のフリーブロックを指すようにします。<br/>
  free関数を呼び出した場合は解放したブロックの直前のフリーブロック(結合した場合は結合後のフリーブロック)を指すようにします。</p>

<p>  このように検索開始位置を変更することで、malloc関数が返却するブロックの位置が偏らないようにします。<br/>
  もし検索開始位置が常に先頭(baseブロック)であれば、フリーブロックリストの前方のブロックが使われやすく、後方のブロックが使われにくくなります。
  そうすると、前方のブロックが細かいブロックに分割され、フラグメンテーションが発生しやすくなるのです。</p>

<p>  freepを使用することで、後方のブロックも使われやすくなるため、フラグメンテーションの発生を抑えることが出来ます。</p>

<p>  また、free関数で解放したブロックを直後のmalloc関数で返却し易くなるため、ハードウエアキャッシュが使われやすくもなります。<br/>
  たいていのプログラムではメモリ解放直前にそのメモリにアクセスする割合が高いと思います。<br/>
  不要になったメモリを解放するのですから、不要になる直前にアクセスがあるはずです。</p>

<p>  また、malloc関数で取得したメモリは、取得した直後に初期化処理などでアクセスする割合が高いと思います。</p>

<p>  free関数の直前でアクセスしてハードウエアキャッシュに置かれたメモリに対してmalloc関数の直後でアクセスするのですから
  ハードウエアキャッシュは有効に働きやすくなります。<br/>
  (局所参照性ってやつです)</p></li>
<li><p>NALLOC</p>

<p>  ヒープ領域からメモリを確保する際の最小サイズです。<br/>
  krmallocではブロックヘッダサイズ単位でメモリを管理するので、</p>

<p>  ブロックヘッダサイズ × NALLOC</p>

<p>  が最小バイト数となります。</p>

<p>  ヒープ領域からメモリを確保するカーネルの処理というのはそれなりにコストが掛かるので、ある程度のサイズを纏めて確保した方が良いのです。</p>

<p>  linuxの場合はページ単位でメモリを管理しています。そのため、数byteずつ確保するとかやるとカーネルとしては既にメモリを確保済みのアドレスに対して
  アドレスのチェック処理だけが奔る形になり、かなり無駄処理なのです。<br/>
  Linuxに限定して考えるならばこのNALLOCはページ単位となるようにすべきなのですが、krmallocはある程度汎用的な処理として書かれているのでこんな感じになっています。</p></li>
</ul>


<h1>アルゴリズム</h1>

<h2>malloc関数</h2>

<p>malloc関数が呼ばれると、まず引数で渡された値で必要とするブロックの大きさを算出します。</p>

<p>前述の通りkrmallocではブロックヘッダのサイズを１単位としてメモリを管理しているので、引数で渡された値を
ブロックヘッダサイズで繰り上げます。</p>

<p>また、mallocが返却するブロック本体だけではなくブロックヘッダも必要です。</p>

<p>つまり、malloc関数で必要とするブロックの大きさは</p>

<p>((引数の値) + (ブロックヘッダサイズ) - 1) / (ブロックヘッダサイズ) + 1</p>

<p>になります。</p>

<p>この大きさ以上のsizeを持つブロックをフリーブロックリストから検索します。
(前述の通りfreepの位置から検索します)</p>

<p>そして、最初に見つかった条件に合うブロックを使用します。</p>

<p>この最初に見つかったブロックを使用するを使用することを「first fit」と呼びます。</p>

<p>最初に見つかったブロックを使用するので速度的には良いのですが、メモリの空間効率としてはあまり良くありません。</p>

<p>もしかしたら、使用することに決めたブロックよりも後ろに丁度良いsizeを持つブロックがあるかもしれません。</p>

<p><img src="http://radlon.github.io/images/2014_08_25/malloc_firstfit.png" alt="CPUバス" /></p>

<p>丁度良いサイズのブロックを使うようにすれば、ブロックの分割が発生し難いので、フラグメンテーションは発生し難くなるはずです。</p>

<p>この丁度良い大きさのブロックを使用するようにすることを「best fit」と呼びます。<br/>
krmallocのアルゴリズムで「best fit」を実現しようとする場合、最悪フリーブロックリストを最後まで走査した上で使用するブロックを選ぶことになるので
速度的にはよろしくありません。</p>

<p>アルゴリズムにも寄りますが、速度と空間効率は互いにトレードオフな関係になるので、krmallocでは速度優先ということで。
(まあ、特定条件下では速度的にもダメダメですが･･･)</p>

<h3>未使用ブロックが見つからない場合</h3>

<p>未使用ブロックの検索で必要な大きさ以上のsizeを持つ未使用ブロックが見つからなかった場合、
ヒープ領域から新たにmallocが管理するメモリを追加します。</p>

<p>追加するメモリサイズは</p>

<p>(必要なブロックの大きさ(ブロックヘッダサイズ単位)) * (ブロックヘッダのサイズ)</p>

<p>です。</p>

<p>ただし、前述のとおりヒープ領域からメモリを確保する際の最小サイズはNALLOCに寄ります。</p>

<p>ヒープ領域からメモリを確保するにはカーネルのシステムコールを使います。</p>

<p>K&amp;RではUNIX環境で話をしているので、sbrk関数を使っています。<br/>
(最近はmmap関数を使うのが主流になっていますが･･･)</p>

<p>WindowsだとWindowsAPIのVirtualAlloc関数を使うことになります。</p>

<p>ヒープ領域からメモリを確保したら、ブロックヘッダを付けます。
そして、そのブロックに対してfree関数を実行し、そのブロックをフリーブロックリストに組み込みます。</p>

<p>そうして、改めてmalloc関数の処理を行います。</p>

<p><img src="http://radlon.github.io/images/2014_08_25/malloc_add_heap.png" alt="ヒープ領域拡張" /></p>

<h3>十分に空いたブロックがある場合</h3>

<p>フリーブロックリストの検索でヒットしたブロックのsizeが必要なブロックの大きさを十分に満たす場合(必要なブロックの大きさよりずっと大きい場合)、
ヒットしたブロックの後ろから削る形で、ブロックを取得します。</p>

<p>ヒットしたブロック内にブロックヘッダを作り、ヒットしたブロックのsizeを変更することで、ヒットしたブロックを分割します。</p>

<p>そして、分割した後ろのブロックを返却します。</p>

<p>この場合はフリーブロックリストの繋ぎなおしなどは必要ありません。</p>

<p><img src="http://radlon.github.io/images/2014_08_25/malloc1.png" alt="十分に空いたブロックの場合" /></p>

<h3>サイズが丁度のブロックを使う場合</h3>

<p>フリーブロックリストの検索でヒットしたブロックのsizeが必要なブロックの大きさに合致した場合は、
ヒットしたブロックを返却します。</p>

<p>そのため、フリーブロックリストからヒットしたブロックを外す必要があります。</p>

<p>ヒットしたブロックの直前のフリーブロックのptrへヒットしたブロックのptrを設定することで、フリーブロックリストから外します。</p>

<p>そして、ヒットしたブロックを返却します。</p>

<p><img src="http://radlon.github.io/images/2014_08_25/malloc2.png" alt="十分に空いたブロックの場合" /></p>

<h2>free関数</h2>

<p>free関数が呼ばれると、引数で指定されたアドレスに対して直前のブロックをフリーブロックリストから検索します。</p>

<p>前述したとおり、フリーブロックリストはブロックのアドレス順になっているので、以下のブロックが直前のブロックとなるはずです。</p>

<ul>
<li>ブロックのアドレスが対象のアドレスよりも前</li>
<li>ブロックのptrが指すブロックのアドレスが対象のアドレスよりも後</li>
</ul>


<p>そして、引数で指定されたアドレスのブロック（以降、対象のブロック）が、
ヒットしたブロック（以降、直前のブロックと呼ぶ）およびヒットしたブロックのptrが指すブロック(以降、直後のフリーブロックと呼ぶ)と
隣接しているかを確認します。</p>

<p><img src="http://radlon.github.io/images/2014_08_25/near_block.png" alt="隣接するブロック判定" /></p>

<h3>隣接するフリーブロックのない場合</h3>

<p>対象のブロックと隣接するフリーブロックが存在しない場合は、対象のブロックをフリーブロックリストに組み込みます。</p>

<ul>
<li>対象のブロックのptrへ前のブロックのptrの値を設定する。</li>
<li>前のブロックのptrへ対象のブロックのアドレスを設定する。</li>
</ul>


<p>こうすることで、対象ブロックを未使用ブロックのリストへ組み込みます。</p>

<p><img src="http://radlon.github.io/images/2014_08_25/free1.png" alt="隣接するブロックがない場合" /></p>

<h3>隣接するフリーブロックがある場合</h3>

<p>対象のブロックと隣接するフリーブロックが存在する場合は隣接するフリーブロックと結合します。</p>

<p>結合しておかないと、malloc関数で分割されたら分割されっぱなしで大きいサイズでmallocができなくなりますからね。</p>

<p>対象のブロックが直後のフリーブロックと隣接する場合、以下を行います。</p>

<ul>
<li>対象のブロックのprtへ、直後のフリーブロックのptrの値を設定する</li>
<li>直前のフリーブロックのptrへ、対象のブロックのアドレスを設定する</li>
<li>対象のブロックのsizeへ、直後のフリーブロックのsizeを加える</li>
</ul>


<p><img src="http://radlon.github.io/images/2014_08_25/free2.png" alt="直後のブロックと隣接する場合" /></p>

<p>対象のブロックが直前のフリーブロックと隣接する場合、以下を行います。</p>

<ul>
<li>直前のブロックのsizeへ、対象のブロックのsizeを加える</li>
</ul>


<p><img src="http://radlon.github.io/images/2014_08_25/free3.png" alt="直後のブロックと隣接する場合" /></p>

<p>前後両方のフリーブロックと隣接する場合は上記の両方を行います。</p>

<h2>K&amp;R mallocの良いところ</h2>

<ul>
<li><p>アルゴリズムが単純</p>

<p>  コードも100行いかないくらいです</p></li>
<li><p>それなりに早い</p>

<p>  ハードウエアキャッシュが使われやすいのも良い！</p></li>
</ul>


<h2>K&amp;R mallocの悪いところ</h2>

<ul>
<li><p>細かいサイズでmalloc関数を何度も呼ぶとフラグメンテーションが進みやすい。</p>

<p>  前述したとおり、first fitなのでフラグメンテーションが発生しやすいです。</p>

<p>  最近のプログラミング言語ではnewするたびにmallocが奔るので、細かいサイズのmalloc関数呼び出しが多発するので
  速攻でフラグメンテーションが進みます。</p></li>
<li><p>フリーブロックリストの検索が遅いときは凄い遅い。</p>

<p>  brk関数が呼ばれる状況では必ずフリーブロックリストを必ず一周しなくてはいけない。<br/>
  freepの直前のブロックしか使える未使用ブロックがなかったりするとフリーブロックリストをほぼ一周してしまう。</p></li>
<li><p>そもそも、マルチスレッド対応してないじゃん。</p>

<p>  K&amp;R出版当時はマルチスレッドありませんしね･･･</p></li>
</ul>


<p>よく使われているmallocアルゴリズムでは、このあたりを改善しています。<br/>
興味があったらglibcのmallocなどを読んでみると良いと思います。
(すげえ長いですが･･･)<br/>
glibcはgithubにも置いてあるので読みやすいと思います。</p>

<h1>最後に</h1>

<p>malloc関数でのメモリ管理ではkrmallocに限らずどのアルゴリズムでも、メモリ管理用の情報分のメモリを消費しますし、
速度や空間効率が極端に悪くなる状況があったりします。</p>

<p>ライブラリのmalloc関数は一般的なアプリケーション向けにチューニングしたアルゴリズムを使うので、
高速で実行したいプログラムや大量にメモリを消費するプログラムなどだと、ここがボトルネックになる場合もあります。</p>

<p>そういう場合は、アプリケーションが独自でメモリ管理を行った方が良いかもしれません。
ライブラリのアルゴリズムはあんまり信用しすぎない方が良いのです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopressにイメージを]]></title>
    <link href="http://radlon.github.io/blog/2014/08/09/image-in-octopress/"/>
    <updated>2014-08-09T19:11:03+09:00</updated>
    <id>http://radlon.github.io/blog/2014/08/09/image-in-octopress</id>
    <content type="html"><![CDATA[<h1>ブログに画像を貼り付けたい</h1>

<p>ブログに画像を貼り付けたいのです。</p>

<!-- more -->


<p>何かしら説明をする上で、画像はなくてはならない要素です。
見た目華やかになりますし、やっぱり画像は貼りたいですよね。</p>

<h1>画像の置き場所</h1>

<p>「source/images/」以下だと思われ。</p>

<p>直下に置いてしまうと、各記事の画像がごちゃ混ぜになってよろしくないので、記事毎にフォルダを切りましょう。</p>

<h1>Markdownの画像指定</h1>

<p>Markdown記法での画像の指定方法は以下です。</p>

<pre><code class="{.md}">![代替テキスト](画像のURL)
</code></pre>

<p>ここで指定する画像のURLはsourceからの相対パスで良いみたいです。</p>

<h1>試してみる</h1>

<p>とりあえず、一般的？な画像サイズ640×480の画像を貼ってみる。</p>

<pre><code class="{.md}">![640×480](/images/2014_08_09/640_480.png)
</code></pre>

<p><img src="http://radlon.github.io/images/2014_08_09/640_480.png" alt="640×480" /></p>

<p>出来た！</p>

<h1>大きい画像</h1>

<p>大きい画像だとどうだろうか？</p>

<p>とりあえず、さっきの画像の倍のサイズの画像を用意してみた。</p>

<pre><code class="{.md}">![1280×960](/images/2014_08_09/1280_960.png)
</code></pre>

<p><img src="http://radlon.github.io/images/2014_08_09/1280_960.png" alt="1280×960" /></p>

<p>フレーム幅に縮小してくれるっぽい。</p>

<p>（適用してるテーマに依ると思いますが）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopressをはじめましょう]]></title>
    <link href="http://radlon.github.io/blog/2014/08/07/start-octopress/"/>
    <updated>2014-08-07T17:45:52+09:00</updated>
    <id>http://radlon.github.io/blog/2014/08/07/start-octopress</id>
    <content type="html"><![CDATA[<p>Octopressの環境構築で若干手間取ったので、記事作成の練習も兼ねて作業手順を纏めてみました。</p>

<!-- more -->


<p>ちなみにMacでの環境構築手順です。</p>

<p>Windowsの場合は若干手順の実行が面倒になる気はしますが、基本は同じだと思います。</p>

<h1>事前準備</h1>

<p>Octopress+gitHubPagesの環境を構築する上での事前準備です。</p>

<h2>gitインストール</h2>

<p>Macにはじめからインストールされてますね。バージョンが古いのでMacPortsで最新版をインストールした方が良いかもです。</p>

<h2>Ruby1.9系インストール</h2>

<p>MacPortsでインストールしましょう。</p>

<h2>rbenvインストール</h2>

<p>MacPortsでインストールしましょう。gitHubに最新版が公開されてるみたいですがインストールめどいですしね。</p>

<h2>gitHubにSSH公開鍵登録</h2>

<p>Octopressで生成したページをgitHubのリポジトリにPushする必要があるので、gitHubにSSH公開鍵を登録しましょう。</p>

<ol>
<li><p>SSH鍵を生成</p>

<p> まず、sshの秘密鍵、公開鍵を格納している.sshフォルダに移動します。</p></li>
</ol>


<pre><code>$ cd ~/.ssh
</code></pre>

<p>   次にssh-keygenで秘密鍵、公開鍵を生成します。
   以下のコマンドの「メールアドレス」には自分のメールアドレスとします。</p>

<pre><code>$ ssh-keygen -t rsa -C "メールアドレス"
</code></pre>

<p>   上記のコマンドを入れると次を聞かれるのでそれぞれ入力します。</p>

<ul>
<li><p> 生成するファイル名</p>

<p>   以下のファイル名で生成されます。</p>

<ul>
<li><p> 秘密鍵のファイル：(入力したファイル名)</p></li>
<li><p> 公開鍵のファイル：(入力したファイル名).pub</p></li>
</ul>
</li>
<li><p> パスフレーズ</p></li>
<li><p> パスフレーズ（確認）</p>

<p>生成した秘密鍵をMacさんに登録します。</p></li>
</ul>


<pre><code>$ ssh-add 秘密鍵のファイル
</code></pre>

<hr />

<p>(2014/08/25 追記)</p>

<p>上記だけではOSを再起動するとSSH Agentさんがssh-addした秘密鍵を忘れちゃうので、
~/.ssh/configに以下を書いておく必要があった。</p>

<pre><code>Host github.com
    User git
    Port 22
    Hostname github.com
    IdentityFile 秘密鍵のファイルへのパス
    TCPKeepAlive yes
    IdentitiesOnly yes
</code></pre>

<hr />

<ol>
<li><p>gitHubに生成した公開鍵を登録</p>

<p> gitHubの自分のページから</p>

<p> Acount settings > SSH keys > Add SSH key</p>

<p> で、公開鍵登録用の画面をだします。</p>

<p> 画面上の「Title」に適当な名前を入力します。</p>

<p> 画面上の「key」に生成した公開鍵のファイルの内容をコピーします。(コピーするのは公開鍵の内容の全コピーです。)</p>

<p> Add keyで登録完了です。</p></li>
</ol>


<h1>Octopress環境構築</h1>

<p>正直<a href="http://octopress.org/docs/setup/">ここ</a>の通りですが</p>

<h2>Octopressをダウンロード</h2>

<pre><code>$ git clone git://github.com/imathis/octopress.git octopress
$ cd octopress
</code></pre>

<h2>bundleインストール</h2>

<pre><code>$ sudo gem install bundler
$ rbenv rehash
$ bundle install
</code></pre>

<p>bundlerを既に導入済みの場合はbundle installだけで良さそうです。</p>

<p>重複してgem install掛けても問題ないと思いますが。</p>

<h2>Octopressデフォルトテーマのインストール</h2>

<pre><code>$ rake install
</code></pre>

<p>たぶんここでインストールするときにオプション付けたりすることでカスタムテーマをインストールできるのだと思う。</p>

<p>まだやってないからわかんないけど。</p>

<h2>公開用のgitHubリポジトリ作成</h2>

<p>ブログを公開するのに使用するgitHubリポジトリを作成する。</p>

<p>あとで、rake deployしたときこのリポジトリにpushされる。</p>

<p>リポジトリ名は「(ユーザ名).github.io」にすると良いらしい。</p>

<p>このブログの場合は「radlon.github.io」にしました。</p>

<p>作成するときに「Initialize this repository with a README」のチェックボックスはオフのままとすると良いです。</p>

<p>このチェックボックスをオンにして作成してしまうとあとでrake deployしようとしたときにPushに失敗します。</p>

<p>(フォースでPushするように設定を変更すればrake deploy出来るようになるらしいですが、面倒ですし)</p>

<h2>公開先のリポジトリ設定</h2>

<pre><code>$ rake setup_github_pages
</code></pre>

<p>上記のコマンドを実行すると、公開先のリポジトリのURLを聞かれます。</p>

<p>さっき作った公開用のgitHubリポジトリのページにあるSSH clone URLを貼り付けてやりましょう。</p>

<p>(「git@github.com:radlon/radlon.github.io.git」みたいなやつです。)</p>

<h2>公開</h2>

<p>まず、次のコマンドでページを生成します。</p>

<pre><code>$ rake generate
</code></pre>

<p>どんな感じにページが生成されたか確認するには次のコマンドを使いましょう。</p>

<pre><code>$ rake preview
</code></pre>

<p><a href="localhost:4000">localhost:4000</a>で確認できます。</p>

<p>良さそうなら次のコマンドで公開先のリポジトリへデプロイします。</p>

<pre><code>$ rake deploy
</code></pre>

<p>これで「(ユーザ名).github.com」に公開されます。</p>

<p>ただし、すぐにアクセスしに行ってもgitHubのエラーページが表示されちゃいます。</p>

<p>エラーページにあるように10分くらい待つと公開されるようです。</p>

<h2>記事作成</h2>

<p>まず、記事のファイルを生成します。</p>

<pre><code>$ rake new_post['(タイトル)']
</code></pre>

<p>「source/_posts/」以下に.markdownファイルが生成されるので、このファイルにMarkdown形式で記事を書きます。</p>

<p>書き終わったら、上記のrake generate以降を行ってデプロイする感じです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello, Octopress!]]></title>
    <link href="http://radlon.github.io/blog/2014/08/06/hello/"/>
    <updated>2014-08-06T18:00:23+09:00</updated>
    <id>http://radlon.github.io/blog/2014/08/06/hello</id>
    <content type="html"><![CDATA[<p>octopressで記事を投稿してみるテストです。</p>
]]></content>
  </entry>
  
</feed>
