<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[らじうむ覚書]]></title>
  <link href="http://radlon.github.io/atom.xml" rel="self"/>
  <link href="http://radlon.github.io/"/>
  <updated>2014-08-31T17:34:00+09:00</updated>
  <id>http://radlon.github.io/</id>
  <author>
    <name><![CDATA[radlon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Sbrk()を読む]]></title>
    <link href="http://radlon.github.io/blog/2014/08/31/sbrk/"/>
    <updated>2014-08-31T16:57:23+09:00</updated>
    <id>http://radlon.github.io/blog/2014/08/31/sbrk</id>
    <content type="html"><![CDATA[<p>K&amp;Rのmallocでカーネルへメモリ確保を要求するのに使用しているsbrk()について、
Linuxではどのように実装されているか読んでみました。</p>

<!-- more -->


<h1>sbrk()</h1>

<p>どうやらsbrk()は外部のライブラリが実装しているようです。</p>

<p>そこで、glibcのsbrk()を読んでみたところ、sbrk()は完全にbrk()のラッパー関数として実装されていました。<br/>
sbrk()で追加するサイズ分、brk()によりbrkの位置を移動します。<br/>
（ちなみに、brk()とはbrkの位置を変更するシステムコールです。念のため)</p>

<p>リニアアドレス上のメモリは以下の図のように使用されます。</p>

<p><img src="http://radlon.github.io/images/2014_08_31/linear_address_space.png" alt="リニアアドレス空間" /></p>

<p>start_brkからbrkまでの間がbrk()およびsbrk()で管理されるメモリです。<br/>
brk()によりbrkの位置を変更することで、メモリの領域を追加、削減するわけです。</p>

<p>brkの位置は基本的にはカーネル側で管理されていますが、glibcではbrkの位置をライブラリ側でも__curbrkに保存していました。
システムコールでわざわざbrkの位置を問い合わせるコストを削減するためですかね？</p>

<h1>brk()</h1>

<p>続けてbrk()の実装を読んでみました。</p>

<p>まず、カレントプロセスのthread_info構造体のtask_struct構造体の持つmm_struct構造体を取得します。</p>

<p>mm_struct構造体はプロセスアドレス空間に関する情報を持っています。</p>

<p>mm_struct構造体は以下のようなメンバをもっています。
なんとなく名前から用途は想像がつくと思います。</p>

<ul>
<li>start_code</li>
<li>end_code</li>
<li>start_data</li>
<li>end_data</li>
<li>start_brk</li>
<li>brk</li>
<li>など(vm_area_struct構造体とかも持ってますよ)</li>
</ul>


<p>brk()ではstart_brkからbrkまでを使用中のメモリとして扱います。</p>

<p>brkをbrk()で渡したアドレスに変更します。</p>

<p>ただし、リニアアドレスの使用状況はmm_struct構造体の持つvm_area_struct構造体でも管理しています。</p>

<p>vm_area_struct構造体ではページ単位でリニアアドレスの使用区間を管理しているようです。<br/>
そのため、変更後のbrkの位置と変更前のbrkの位置が別々のページになる場合、vm_area_struct構造体の更新も行います。</p>

<p>vm_area_struct構造体は双方向リストとして構成されており、vm_startからvm_endまでを区間としています。</p>

<p>また、必要なら(mlockall()でmm->def_flagにVM_LOCKEDフラグを立てていれば)追加したアドレスに対してmlock()と同等の処理を行い追加したメモリがページアウトされることを防ぐようにします。</p>

<p>細部は飛ばしましたが、こんな感じのようです。</p>

<p>基本的にmmap()でもだいたい同じような感じの処理をしているっぽいです。<br/>
(brk()の内部処理はmmapの処理のサブセット的な処理のようです。)</p>

<p>やっぱり、メモリ確保だけでもカーネル側で結構いろいろ処理してますね。<br/>
アプリケーションを組む上では、割と誤差の範囲レベルの処理コストとはいえ、高速化を図るならカーネルにメモリをこまめに要求するようなロジックはよろしくないのがよくわかります。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[K&R Malloc解説]]></title>
    <link href="http://radlon.github.io/blog/2014/08/25/krmalloc/"/>
    <updated>2014-08-25T23:00:00+09:00</updated>
    <id>http://radlon.github.io/blog/2014/08/25/krmalloc</id>
    <content type="html"><![CDATA[<p>なにか、無闇に時間掛かってしまった･･･</p>

<p>後で見直して直すと思います。</p>

<p>数あるmallocアルゴリズムの基本であるK&amp;Rのmallocアルゴリズムを解説いたします。</p>

<!-- more -->


<p>K&amp;Rとは初期のC言語を解説した書籍「プログラミング言語C」(原題:The Programing Language)のことです。</p>

<p>著者であるブライアン・カーニハン氏(Brian W. Kernighan)とデニス・リッチー氏(Dennis M. Ritchie)の頭文字をとってK&amp;Rと呼ばれています。</p>

<p>malloc関数とはヒープ領域から、指定したサイズのメモリを動的に確保する関数です。<br/>
C言語などの低レベルの処理を記述する言語では馴染みのある関数です。<br/>
Javaなど低レベルの処理を記述しない言語しか使用していない人には、あまり馴染みがないでしょうか？</p>

<p>malloc関数で確保したメモリは対応するfree関数で解放いたします。<br/>
明示的にメモリを解放しなければ解放されることはありません。<br/>
もちろん、ここで確保されるのは仮想メモリ空間のメモリですので、
基本的にはプロセスが終了する際に解放されます。</p>

<h1>データ構造</h1>

<p>krmallocではメモリをブロック単位で管理します。<br/>
ブロックは以下の構造をしています。</p>

<p><img src="http://radlon.github.io/images/2014_08_25/data_struct.png" alt="データ構造" /></p>

<ul>
<li><p>ブロックヘッダ</p>

<ul>
<li><p>ブロック情報</p>

<ul>
<li><p>ptr</p>

<p>  次のブロックへのポインタ</p></li>
<li><p>size</p>

<p>  ブロック全体(ブロックヘッダとブロック本体)のサイズ。<br/>
  このsizeはバイト数ではなくブロックヘッダを１単位としたサイズです。</p></li>
</ul>
</li>
<li><p>アライメント調整値(Align)</p></li>
</ul>
</li>
<li><p>ブロック本体</p>

<p>  mallocで返却し、呼び出し元が使用するメモリ。<br/>
  ブロック本体のサイズはブロックヘッダのサイズの倍数とします。</p></li>
</ul>


<p>krmallocではブロックヘッダのサイズを１単位としてメモリを管理します。</p>

<p>mallocで要求されたサイズがブロックヘッダサイズ以下であってもブロックヘッダサイズで割り当てます。</p>

<p>ブロックヘッダサイズ単位でメモリを管理するのは、後述するmallocのアルゴリズムでブロックを分割・結合を行う処理があるためです。</p>

<p>現在未使用のブロックはptrによりリング状の一方向リストとします。</p>

<p><img src="http://radlon.github.io/images/2014_08_25/example_list.png" alt="データ構造のリスト" /></p>

<p>図のbaseはsizeが0のブロック本体を持たないブロックで、グローバル変数として定義します。</p>

<p>未使用ブロックが存在しない場合、未使用ブロックのリストはこのbaseのみを持つ形になります。</p>

<p>このリストのブロックの並び順は、図のようにブロックのアドレスが前後しない順序を維持します。</p>

<p>こうすることで、対象のブロックの前後に未使用ブロックが隣接するかを判断し易くします。</p>

<p>(リストの順がバラバラだとリストを一周しないと前後の未使用ブロックが判別できません)</p>

<p>krmallocではこのリストから、要求されたサイズのブロックを外して返却する形になります。</p>

<p>また、free関数で指定されたブロックは、このリストへ組み込み、次回以降のmalloc呼び出し時に返却する対象にします。</p>

<h2>アライメント</h2>

<p>先ほどのアライメントを合わせるという言葉が出ましたが、
アライメントという言葉を覚えているでしょうか？</p>

<p>CPUとメモリは複数本のバスで繋がっています。メモリを読み込む場合このバスの本数分の範囲をパラレルに読み込みます。</p>

<p><img src="http://radlon.github.io/images/2014_08_25/cpu_databus.png" alt="CPUバス" /></p>

<p>CPUは上記の図のようにしてメモリを読み込みます。</p>

<p>メモリ上の値はそのサイズにより決まった区切りに収まる形で配置します。</p>

<p>1byteの値を図のbyteのマス２つに跨がって配置することはできません。必ず1マスに納めます。</p>

<p>メモリ上に区切り位置を跨がった形で値を配置した場合、エラーが発生します。</p>

<p>この区切りをアライメントと呼びます。</p>

<p>C言語において、構造体および共用体のアライメントはメンバのうちの最もアライメントの制限が厳しい型のアライメントが適用されます。</p>

<p>構造体のサイズがメンバのサイズの合計とならないのはこのためです。</p>

<p>mallocで返却したメモリはあらゆる型で使用します。
そのため、ブロックヘッダにアライメント調整値としてあらゆる型で最もアライメントの制限が厳しい型を使用します。</p>

<p>ここでいう最もアライメントの制限が厳しい型というのは、プログラミング言語の言語仕様ではなく、
CPUの仕様に依存します。</p>

<p>そうすることで、ブロック本体の位置があらゆる型のアライメントにあった位置となります。</p>

<p>ちなみに、このようにアライメントを合わせるため、mallocが返却するアドレスの下位数ビットは必ず0になります。</p>

<p>glibcのdlmallocでは、このことを利用してptrの値の下位数ビットをフラグとして利用しています。</p>

<h1>アルゴリズム</h1>

<h2>malloc</h2>

<p>mallocが呼ばれると、まずmallocが要求するサイズで使用するブロックのsizeを算出します。</p>

<p>前述の通りkrmallocではブロックヘッダのサイズを１単位としてメモリを管理しています。</p>

<p>そのため、ブロック本体のサイズはブロックヘッダサイズで繰り上げた値となります。</p>

<p>また、mallocが返却するブロック本体だけではなくブロックヘッダも必要です。</p>

<p>つまり、mallocが返却するブロックのsizeは以下になります。</p>

<p>((mallocで要求されたサイズ) + (ブロックヘッダサイズ) - 1) / (ブロックヘッダサイズ) + 1</p>

<p>このsize以上のsizeを持つブロックを未使用ブロックのリストからfreepの位置を始点にして探します。</p>

<p>そして、最初に見つかった条件に合うsizeを持つ未使用ブロックを使用します。</p>

<p>この最初に見つかった未使用ブロックを使用するを使用することを「first fit」と呼びます。</p>

<p><img src="http://radlon.github.io/images/2014_08_25/malloc1.png" alt="malloc1" /></p>

<h3>未使用ブロックが見つからない場合</h3>

<p>条件に合うsizeの未使用ブロックが見つからなかった場合、
ヒープ領域から新たにmallocが管理するメモリを追加します。</p>

<p>追加するメモリサイズは</p>

<p>(mallocが返却するブロックのsize) * (ブロックヘッダのサイズ)</p>

<p>です。</p>

<p>ただし、sizeが要求最小size(K&amp;Rでは1024)未満の場合は、この最小sizeを追加します。</p>

<p>メモリを確保するには、カーネルへヒープ領域から新たにメモリを確保するように要求します。
この処理にはそれなりのコストがかかります。<br/>
細かいサイズを連続して確保するのは効率が良くありません。<br/>
なのでmallocで要求されたサイズが小さかったとしても、
ある程度のサイズのメモリを確保するようにします。</p>

<p>確保したメモリは、ブロックヘッダを付けた上で、そのブロックに対してfreeを実行します。</p>

<p>これにより、確保したメモリのブロックは未使用ブロックのリストへ組み込まれます。</p>

<p><img src="http://radlon.github.io/images/2014_08_25/malloc2.png" alt="malloc2" /></p>

<p>そして、改めてmallocの処理を実行します。</p>

<h3>十分に空いたブロックがある場合</h3>

<p>未使用ブロックのリストを探索した結果、sizeに「(mallocの呼び出し元から要求されたサイズ)+(ブロックヘッダのサイズ)」以上を
持つブロックが見つかった場合、見つかったブロックの後方から必要なサイズのブロックを削り出す形でブロックを取得します。</p>

<p>この場合、未使用ブロックのリストの組み替えは必要ありません。</p>

<p>削り出したブロックへブロックヘッダを書き込み、
使用した未使用ブロックのsizeのみ更新します。</p>

<p><img src="http://radlon.github.io/images/2014_08_25/malloc3.png" alt="malloc3" /></p>

<p>そして、mallocの呼び出しもとへ削りだしたブロックのブロック本体のアドレスを返却します。</p>

<h3>サイズが丁度のブロックを使う場合</h3>

<p>未使用ブロックのリストを探索した結果、sizeに「(mallocの呼び出し元から要求されたサイズ)」以上、「(mallocの呼び出し元から要求されたサイズ)+(ブロックヘッダのサイズ)」未満を
持つブロックが見つかった場合、
見つかったブロックを未使用ブロックのリストから外します。</p>

<p>前のブロックのヘッダーのptrをヒットしたブロックのptrへ書き換えることで、ヒットしたブロックを
未使用ブロックのリストから外します。</p>

<p><img src="http://radlon.github.io/images/2014_08_25/malloc4.png" alt="malloc4" /></p>

<p>そして、mallocの呼び出し元へ見つかったブロックのブロック本体のアドレスを返却します。</p>

<h2>free</h2>

<p>freeが呼ばれると、freeで指定されたブロックに対してリニアアドレス上で直前の未使用ブロックを、
未使用ブロックのリストから検索します。</p>

<p>未使用ブロックのリストのブロックの順序はリニアアドレス上のアドレスの順で維持しているので、
freeで指定されたブロックのアドレスと比較することで、検索が可能です。</p>

<p>ちなみに、この検索でもfreepを始点とします。</p>

<p>そして、みつけた未使用のブロックおよび未使用のブロックのptrが示す次のブロックが、対象のブロックと隣接しているかを確認します。</p>

<h3>隣接する未使用ブロックのない場合</h3>

<p>隣接する未使用ブロックが存在しない場合、freeが指定したブロックを未使用ブロックのリストへ組み込みます。</p>

<ul>
<li>対象のブロックのptrへ前のブロックのptrの値を設定する。</li>
<li>前のブロックのptrへ対象のブロックのアドレスを設定する。</li>
</ul>


<p>これにより、対象ブロックを未使用ブロックのリストへ組み込みます。</p>

<p><img src="http://radlon.github.io/images/2014_08_25/free1.png" alt="free1" /></p>

<h3>隣接する未使用ブロックがある場合</h3>

<p>対象のブロックに隣接する未使用のブロックがある場合は、
対象のブロックと未使用のブロックを結合します。</p>

<p>対象のブロックを後ろのブロックと結合する場合、以下を行います。</p>

<ul>
<li>対象のブロックのprtへ後ろのブロックのptrの値を設定する</li>
<li>対象のブロックのsizeへ「後のブロックのsize」を加える</li>
</ul>


<p>対象のブロックを前のブロックと結合する場合、以下を行います。</p>

<ul>
<li>前のブロックのptrへ対象のブロックのptrの値を設定する。(後ろのブロックと結合していない場合は変更しない)</li>
<li>前のブロックのsizeへ「対象のブロックのsize」を加える</li>
</ul>


<p><img src="http://radlon.github.io/images/2014_08_25/free2.png" alt="free2" /></p>

<h2>freepとはなんだったのか？</h2>

<p>freepはmallocを行った場合は返却したブロックの直前の未使用ブロック、
freeを行った場合は解放したブロックに移動します。</p>

<p>このようにして検索開始位置を移動するのは、使用するブロックに偏りを持たせないため
･･･ということになっています。</p>

<p>毎回先頭から未使用ブロックを検索したのでは、後ろの方にある大きな未使用ブロックが使われ難くなり、
前の方の小さなブロックばかりが使われ易なります。</p>

<p>大きな未使用ブロックから必要なサイズを削るだけ(未使用ブロックのsizeを変更するのみ）の方が、
未使用ブロックのリストをつなぎ直すよりも楽であるため、このようにしているとなっています。</p>

<p>しかし、実際のところfreepを使用することは、上記とは別の大きな効果に繋がっています。</p>

<p>たいていのプロセスは</p>

<p>メモリ確保>メモリ解放>メモリ確保>メモリ解放>…</p>

<p>のように、
確保したメモリをすぐに解放しています。</p>

<p>また、mallocした直後とfreeする直前に対象のメモリへアクセスを行うことが多いと思います。</p>

<p>(malloc直後は初期化のため、freeは不要になったときなので直前に使っていることが多いはず)</p>

<p>そのため、freeしたアドレス付近のメモリはハードキャッシュに乗っている確率が非常に多いです。</p>

<p>そして、malloc直後にアクセスするので、mallocした時点でハードキャッシュに載っていることは、非常に有利です。</p>

<p>freepを使用すると、直前にfreeしたメモリを優先的にmallocで使うことになるため、ハードキャッシュに乗ったメモリが使われ易い
ので非常に良いということです。</p>

<h2>フラグメンテーション</h2>

<p>krmallocではfirst fitで使用するブロックを決定します。</p>

<p>要求したサイズに丁度良いサイズの未使用ブロックがあったとしても、
大きなブロックを削ってメモリ確保をすることになりやすいため、
リニアなメモリ空間上に細かい空きが出来易くなります。</p>

<p>これにより、空いているメモリサイズの総量は十分にあるのにメモリを確保出来ないという状態が発生します</p>

<p>これを「フラグメンテーション」と呼びます。</p>

<p><img src="http://radlon.github.io/images/2014_08_25/fragment.png" alt="フラグメンテーション" /></p>

<p>とはいえ、krmallocのアルゴリズムではbest fitとなるブロックを検索するというのは
コストが掛かりすぎます。</p>

<p>(最悪、全未使用ブロックを走査することになる)</p>

<p>glibcのdlmallocアルゴリズムでは、未使用ブロックをサイズ毎に管理するbins配列を使用することでbest fitを実現しています。</p>

<h1>最後に</h1>

<p>mallocでメモリを確保する場合、解説したようにブロックヘッダ分のメモリを消費したり、
メモリ管理のための処理など、アプリケーション作成者の意図しないコストが掛かります。</p>

<p>もしかしたら、アプリケーション作者が自力でメモリ管理を行った方が良いかもしれません。</p>

<p>普段はあまり意識しないかもしれませんが、アプリケーションの高速化または軽量化を行う場合は
このあたりに立ち返って設計を行うと良いと思いますよ。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopressにイメージを]]></title>
    <link href="http://radlon.github.io/blog/2014/08/09/image-in-octopress/"/>
    <updated>2014-08-09T19:11:03+09:00</updated>
    <id>http://radlon.github.io/blog/2014/08/09/image-in-octopress</id>
    <content type="html"><![CDATA[<h1>ブログに画像を貼り付けたい</h1>

<p>ブログに画像を貼り付けたいのです。</p>

<!-- more -->


<p>何かしら説明をする上で、画像はなくてはならない要素です。
見た目華やかになりますし、やっぱり画像は貼りたいですよね。</p>

<h1>画像の置き場所</h1>

<p>「source/images/」以下だと思われ。</p>

<p>直下に置いてしまうと、各記事の画像がごちゃ混ぜになってよろしくないので、記事毎にフォルダを切りましょう。</p>

<h1>Markdownの画像指定</h1>

<p>Markdown記法での画像の指定方法は以下です。</p>

<pre><code class="{.md}">![代替テキスト](画像のURL)
</code></pre>

<p>ここで指定する画像のURLはsourceからの相対パスで良いみたいです。</p>

<h1>試してみる</h1>

<p>とりあえず、一般的？な画像サイズ640×480の画像を貼ってみる。</p>

<pre><code class="{.md}">![640×480](/images/2014_08_09/640_480.png)
</code></pre>

<p><img src="http://radlon.github.io/images/2014_08_09/640_480.png" alt="640×480" /></p>

<p>出来た！</p>

<h1>大きい画像</h1>

<p>大きい画像だとどうだろうか？</p>

<p>とりあえず、さっきの画像の倍のサイズの画像を用意してみた。</p>

<pre><code class="{.md}">![1280×960](/images/2014_08_09/1280_960.png)
</code></pre>

<p><img src="http://radlon.github.io/images/2014_08_09/1280_960.png" alt="1280×960" /></p>

<p>フレーム幅に縮小してくれるっぽい。</p>

<p>（適用してるテーマに依ると思いますが）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopressをはじめましょう]]></title>
    <link href="http://radlon.github.io/blog/2014/08/07/start-octopress/"/>
    <updated>2014-08-07T17:45:52+09:00</updated>
    <id>http://radlon.github.io/blog/2014/08/07/start-octopress</id>
    <content type="html"><![CDATA[<p>Octopressの環境構築で若干手間取ったので、記事作成の練習も兼ねて作業手順を纏めてみました。</p>

<!-- more -->


<p>ちなみにMacでの環境構築手順です。</p>

<p>Windowsの場合は若干手順の実行が面倒になる気はしますが、基本は同じだと思います。</p>

<h1>事前準備</h1>

<p>Octopress+gitHubPagesの環境を構築する上での事前準備です。</p>

<h2>gitインストール</h2>

<p>Macにはじめからインストールされてますね。バージョンが古いのでMacPortsで最新版をインストールした方が良いかもです。</p>

<h2>Ruby1.9系インストール</h2>

<p>MacPortsでインストールしましょう。</p>

<h2>rbenvインストール</h2>

<p>MacPortsでインストールしましょう。gitHubに最新版が公開されてるみたいですがインストールめどいですしね。</p>

<h2>gitHubにSSH公開鍵登録</h2>

<p>Octopressで生成したページをgitHubのリポジトリにPushする必要があるので、gitHubにSSH公開鍵を登録しましょう。</p>

<ol>
<li><p>SSH鍵を生成</p>

<p> まず、sshの秘密鍵、公開鍵を格納している.sshフォルダに移動します。</p></li>
</ol>


<pre><code>$ cd ~/.ssh
</code></pre>

<p>   次にssh-keygenで秘密鍵、公開鍵を生成します。
   以下のコマンドの「メールアドレス」には自分のメールアドレスとします。</p>

<pre><code>$ ssh-keygen -t rsa -C "メールアドレス"
</code></pre>

<p>   上記のコマンドを入れると次を聞かれるのでそれぞれ入力します。</p>

<ul>
<li><p> 生成するファイル名</p>

<p>   以下のファイル名で生成されます。</p>

<ul>
<li><p> 秘密鍵のファイル：(入力したファイル名)</p></li>
<li><p> 公開鍵のファイル：(入力したファイル名).pub</p></li>
</ul>
</li>
<li><p> パスフレーズ</p></li>
<li><p> パスフレーズ（確認）</p>

<p>生成した秘密鍵をMacさんに登録します。</p></li>
</ul>


<pre><code>$ ssh-add 秘密鍵のファイル
</code></pre>

<hr />

<p>(2014/08/25 追記)</p>

<p>上記だけではOSを再起動するとSSH Agentさんがssh-addした秘密鍵を忘れちゃうので、
~/.ssh/configに以下を書いておく必要があった。</p>

<pre><code>Host github.com
    User git
    Port 22
    Hostname github.com
    IdentityFile 秘密鍵のファイルへのパス
    TCPKeepAlive yes
    IdentitiesOnly yes
</code></pre>

<hr />

<ol>
<li><p>gitHubに生成した公開鍵を登録</p>

<p> gitHubの自分のページから</p>

<p> Acount settings > SSH keys > Add SSH key</p>

<p> で、公開鍵登録用の画面をだします。</p>

<p> 画面上の「Title」に適当な名前を入力します。</p>

<p> 画面上の「key」に生成した公開鍵のファイルの内容をコピーします。(コピーするのは公開鍵の内容の全コピーです。)</p>

<p> Add keyで登録完了です。</p></li>
</ol>


<h1>Octopress環境構築</h1>

<p>正直<a href="http://octopress.org/docs/setup/">ここ</a>の通りですが</p>

<h2>Octopressをダウンロード</h2>

<pre><code>$ git clone git://github.com/imathis/octopress.git octopress
$ cd octopress
</code></pre>

<h2>bundleインストール</h2>

<pre><code>$ sudo gem install bundler
$ rbenv rehash
$ bundle install
</code></pre>

<p>bundlerを既に導入済みの場合はbundle installだけで良さそうです。</p>

<p>重複してgem install掛けても問題ないと思いますが。</p>

<h2>Octopressデフォルトテーマのインストール</h2>

<pre><code>$ rake install
</code></pre>

<p>たぶんここでインストールするときにオプション付けたりすることでカスタムテーマをインストールできるのだと思う。</p>

<p>まだやってないからわかんないけど。</p>

<h2>公開用のgitHubリポジトリ作成</h2>

<p>ブログを公開するのに使用するgitHubリポジトリを作成する。</p>

<p>あとで、rake deployしたときこのリポジトリにpushされる。</p>

<p>リポジトリ名は「(ユーザ名).github.io」にすると良いらしい。</p>

<p>このブログの場合は「radlon.github.io」にしました。</p>

<p>作成するときに「Initialize this repository with a README」のチェックボックスはオフのままとすると良いです。</p>

<p>このチェックボックスをオンにして作成してしまうとあとでrake deployしようとしたときにPushに失敗します。</p>

<p>(フォースでPushするように設定を変更すればrake deploy出来るようになるらしいですが、面倒ですし)</p>

<h2>公開先のリポジトリ設定</h2>

<pre><code>$ rake setup_github_pages
</code></pre>

<p>上記のコマンドを実行すると、公開先のリポジトリのURLを聞かれます。</p>

<p>さっき作った公開用のgitHubリポジトリのページにあるSSH clone URLを貼り付けてやりましょう。</p>

<p>(「git@github.com:radlon/radlon.github.io.git」みたいなやつです。)</p>

<h2>公開</h2>

<p>まず、次のコマンドでページを生成します。</p>

<pre><code>$ rake generate
</code></pre>

<p>どんな感じにページが生成されたか確認するには次のコマンドを使いましょう。</p>

<pre><code>$ rake preview
</code></pre>

<p><a href="localhost:4000">localhost:4000</a>で確認できます。</p>

<p>良さそうなら次のコマンドで公開先のリポジトリへデプロイします。</p>

<pre><code>$ rake deploy
</code></pre>

<p>これで「(ユーザ名).github.com」に公開されます。</p>

<p>ただし、すぐにアクセスしに行ってもgitHubのエラーページが表示されちゃいます。</p>

<p>エラーページにあるように10分くらい待つと公開されるようです。</p>

<h2>記事作成</h2>

<p>まず、記事のファイルを生成します。</p>

<pre><code>$ rake new_post['(タイトル)']
</code></pre>

<p>「source/_posts/」以下に.markdownファイルが生成されるので、このファイルにMarkdown形式で記事を書きます。</p>

<p>書き終わったら、上記のrake generate以降を行ってデプロイする感じです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello, Octopress!]]></title>
    <link href="http://radlon.github.io/blog/2014/08/06/hello/"/>
    <updated>2014-08-06T18:00:23+09:00</updated>
    <id>http://radlon.github.io/blog/2014/08/06/hello</id>
    <content type="html"><![CDATA[<p>octopressで記事を投稿してみるテストです。</p>
]]></content>
  </entry>
  
</feed>
