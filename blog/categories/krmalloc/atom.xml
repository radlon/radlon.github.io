<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Krmalloc | らじうむ覚書]]></title>
  <link href="http://radlon.github.io/blog/categories/krmalloc/atom.xml" rel="self"/>
  <link href="http://radlon.github.io/"/>
  <updated>2014-09-15T23:49:05+09:00</updated>
  <id>http://radlon.github.io/</id>
  <author>
    <name><![CDATA[radlon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[K&R Malloc解説]]></title>
    <link href="http://radlon.github.io/blog/2014/08/25/krmalloc/"/>
    <updated>2014-08-25T23:00:00+09:00</updated>
    <id>http://radlon.github.io/blog/2014/08/25/krmalloc</id>
    <content type="html"><![CDATA[<p>結構なおした。
こんなもんかなあ…</p>

<p>K&amp;Rのmallocアルゴリズムを解説します。</p>

<!-- more -->


<p>K&amp;Rとは初期のC言語を解説した書籍「プログラミング言語C」(原題:The Programing Language)のことです。</p>

<p>著者であるブライアン・カーニハン氏(Brian W. Kernighan)とデニス・リッチー氏(Dennis M. Ritchie)の頭文字をとってK&amp;Rと呼ばれています。</p>

<p>この本の第8章 UNIXシステム・インターフェースにmalloc関数の実装例が紹介されています。</p>

<h1>mallocとは</h1>

<p>malloc関数とはヒープ領域から、指定したサイズのメモリを動的に確保する関数です。</p>

<p>malloc関数で確保したメモリは対応するfree関数で解放します。</p>

<p>明示的にメモリを解放しなければ解放されることはありません。<br/>
(まあ、プロセスが終了すれば解放されますが･･･)</p>

<p>K&amp;Rで紹介されているmallocアルゴリズムは現在実用されているmallocアルゴリズムの基となったアルゴリズムなので、
ある程度考え方が共通しています。<br/>
krmallocを知っておくと他のmallocを読むときに把握しやすくなると思います。</p>

<h1>データ構造</h1>

<p>krmallocではブロック単位でメモリを管理します。<br/>
各ブロックの先頭には以下の定義のブロックヘッダを持ち、ブロックの情報を格納しています。</p>

<pre><code class="{.c}">typedef long Aling; /* long の境界に整合させる */

union header {      /* ブロックのヘッダ */
    struct {
        union header *ptr;  /* 空きリストの上なら次のブロック */
        unsigned size;      /* このブロックの大きさ */
    } s;
    Align x;                /* ブロックの整合を強制 */
};

typedef union header Header;
</code></pre>

<ul>
<li><p>ptr</p>

<p>  次のブロックへのポインタです。<br/>
  krmallocでは未使用のブロックをリング上の一方向リストで管理します。<br/>
  使用中のブロックでは使用しません。</p></li>
<li><p>size</p>

<p>  ブロックの大きさです。
  この値はバイトサイズではなく、ブロックヘッダサイズを１単位とした値とします。</p>

<p>  krmallocではブロックヘッダサイズ単位でメモリを管理しています。<br/>
  (ブロックヘッダサイズの要素を持つ配列でメモリを管理しているイメージです)</p>

<p>  そのため、malloc関数で実際に確保されるメモリサイズはブロックヘッダサイズが最小となります。<br/>
  ブロックヘッダサイズ未満のサイズをmalloc関数で確保しようとしても、ブロックヘッダサイズで確保されるのです。</p>

<p>  <img src="/images/2014_08_25/memory_manage_image.png" alt="メモリ管理のイメージ図" /></p></li>
<li><p>x</p>

<p>  ブロックのアライメントを強制するためのメンバです。<br/>
  この値へのアクセス自体はありません。</p></li>
</ul>


<h2>フリーブロックリスト</h2>

<p>krmallocでは未使用のブロックをリング状の一方向リストとします。
(ここではこのリストをフリーブロックリストと呼ぶことにします。)</p>

<p>一方向リストとは要素が次の要素を指すことで、形成するリストのことを言います。</p>

<p>フリーブロックリストの場合はリスト最後の要素がリストの最初の要素をさすようにすることで、
リストをリング状にしています。</p>

<p>このフリーブロックリストは検索性のために、リスト内のブロックの順序はブロックのアドレス順を維持するようにします。</p>

<p><img src="/images/2014_08_25/free_block_list.png" alt="フリーブロックリスト" /></p>

<p>また、フリーブロックは隣接しないようにします。
フリーブロックが隣接していると、ブロックヘッダー分のメモリが無駄になるし、
利用出来るフリーブロックが細切れになり、大きなメモリを確保できなくなるためです。</p>

<p>そのため、free関数呼び出しで、フリーブロックが隣接するようになりそうなら、
隣接するフリーブロックは一つのフリーブロックに結合してしまいます。</p>

<p>malloc関数が呼ばれるとこのフリーブロックリストから適当なブロックを取り出し、アドレスを返却します。
また、free関数が呼ばれると引数で指定されたアドレスが指すブロックをフリーブロックリストに追加します。</p>

<h2>アライメント</h2>

<p>ブロックヘッダのxについて、アライメントを強制するためと説明しました。<br/>
アライメントについて簡単に解説します。</p>

<p>CPUとメモリは複数本のバス(データバス)で繋がっています。メモリを読み込む場合このデータバスの本数分の範囲をパラレルに読み込みます。</p>

<p><img src="/images/2014_08_25/cpu_databus.png" alt="CPUバス" /></p>

<p>このようにメモリを読み込むため、図の0x00000002から0x0000006に4byteの値を配置すると
CPUはメモリへ２回アクセスする必要があります。
多少メモリの空間効率が悪くなったとしても0x00000004から0x00000007に配置した方が
１度のメモリアクセスで済むので実行効率は良くなります。</p>

<p>そのため、CPUではメモリ上に値を配置する際の位置を値のサイズ毎に決めています。</p>

<p>この位置を合わせることをアライメントを合わせると良く言います。</p>

<p>CPUはCPUの仕様で定義されたアライメントに合わせてメモリ上に値が配置されていると想定して実装されているため、
アライメントが合っていないとエラーになる場合があります。<br/>
(アライメントが合っていなくても問題がないCPUもあるらしいですが、どちらにせよ実行効率が良くなるわけではないので
そういうCPUでも基本的にはアライメントを合わせた方が良いと思います。)</p>

<p>それから、C言語の構造体および共用体のアライメントはメンバのうちの最もアライメントの制限が厳しい型(サイズの最も大きい型と言って良いかも)のアライメントが適用されます。</p>

<pre><code class="{.c}">union Hoge{
    long int x;
    short int y;
};
</code></pre>

<p>上記のような共用体の場合、各メンバのサイズはxが4byte,yが2byteで、直感的には共用体のサイズは6byteとなりますが、
先の説明のようにアライメントは最も制限が厳しい型が適用されます。
ここではshort intよりもlong intの方が明らかに制限が厳しいので、long intのアライメントが適用されます。
そのため、共用体のサイズは8byteとなります。</p>

<p>malloc関数が返却するメモリはあらゆる型で使用します。
そのため、ブロックヘッダのアライメントはあらゆる型で最もアライメントの制限が厳しい型に合わせる必要があります。</p>

<p>ちなみに、ここでいう最もアライメントの制限が厳しい型というのは、プログラミング言語の言語仕様ではなく、
CPUの仕様に依存します。<br/>
(最もアライメントの制限が厳しい型はたいていCPUのデータバスのサイズ以上になります。)</p>

<p>ちなみに、このようにアライメントを合わせるため、バイトマシンではmalloc関数が返却するアドレスの下位数ビットは必ず0になります。
(32bitマシンであれば、下位2bitが0となる。)</p>

<p>glibcのmallocでは、さらにブロックサイズの調整をしてアドレスの下位3bitが必ず0になるようにしています。
そうして、glibcのmallocではこの必ず0となる3bitをフラグとして利用することで、メモリ管理に使用するメモリサイズを削減しています。
(若干やりすぎ感がありますが…)</p>

<h1>グローバル変数</h1>

<p>アルゴリズムの解説に入る前に、krmallocで使用するグローバル変数および定数について紹介します。</p>

<pre><code class="{.c}">static Header base;     /* 開始時の空きリスト */
static Header *freep = NULL;    /* 空きリストの先頭 */

#define NALLOC  1024    /* 要求する最小の単位数 */
</code></pre>

<ul>
<li><p>base</p>

<p>  size=0のブロックヘッダのみのブロックです。
  開始時のフリーブロックリストの先頭となるブロックです。</p>

<p>  プロセス開始時または全てのブロックが使用中の場合、フリーブロックリストはこのbaseブロックしか持ちません。</p></li>
<li><p>freep</p>

<p>  malloc関数で返却するブロックをフリーブロックリストから検索する際の検索開始位置を示すポインタです。<br/>
  free関数で解放するブロックに隣接するブロックの検索時の検索開始位置でもあります。</p>

<p>  malloc関数呼び出し時は、処理終了時に返却するブロックの直前のフリーブロックを指すようにします。<br/>
  free関数を呼び出した場合は解放したブロックの直前のフリーブロック(結合した場合は結合後のフリーブロック)を指すようにします。</p>

<p>  このように検索開始位置を変更することで、malloc関数が返却するブロックの位置が偏らないようにします。<br/>
  もし検索開始位置が常に先頭(baseブロック)であれば、フリーブロックリストの前方のブロックが使われやすく、後方のブロックが使われにくくなります。
  そうすると、前方のブロックが細かいブロックに分割され、フラグメンテーションが発生しやすくなるのです。</p>

<p>  freepを使用することで、後方のブロックも使われやすくなるため、フラグメンテーションの発生を抑えることが出来ます。</p>

<p>  また、free関数で解放したブロックを直後のmalloc関数で返却し易くなるため、ハードウエアキャッシュが使われやすくもなります。<br/>
  たいていのプログラムではメモリ解放直前にそのメモリにアクセスする割合が高いと思います。<br/>
  不要になったメモリを解放するのですから、不要になる直前にアクセスがあるはずです。</p>

<p>  また、malloc関数で取得したメモリは、取得した直後に初期化処理などでアクセスする割合が高いと思います。</p>

<p>  free関数の直前でアクセスしてハードウエアキャッシュに置かれたメモリに対してmalloc関数の直後でアクセスするのですから
  ハードウエアキャッシュは有効に働きやすくなります。<br/>
  (局所参照性ってやつです)</p></li>
<li><p>NALLOC</p>

<p>  ヒープ領域からメモリを確保する際の最小サイズです。<br/>
  krmallocではブロックヘッダサイズ単位でメモリを管理するので、</p>

<p>  ブロックヘッダサイズ × NALLOC</p>

<p>  が最小バイト数となります。</p>

<p>  ヒープ領域からメモリを確保するカーネルの処理というのはそれなりにコストが掛かるので、ある程度のサイズを纏めて確保した方が良いのです。</p>

<p>  linuxの場合はページ単位でメモリを管理しています。そのため、数byteずつ確保するとかやるとカーネルとしては既にメモリを確保済みのアドレスに対して
  アドレスのチェック処理だけが奔る形になり、かなり無駄処理なのです。<br/>
  Linuxに限定して考えるならばこのNALLOCはページ単位となるようにすべきなのですが、krmallocはある程度汎用的な処理として書かれているのでこんな感じになっています。</p></li>
</ul>


<h1>アルゴリズム</h1>

<h2>malloc関数</h2>

<p>malloc関数が呼ばれると、まず引数で渡された値で必要とするブロックの大きさを算出します。</p>

<p>前述の通りkrmallocではブロックヘッダのサイズを１単位としてメモリを管理しているので、引数で渡された値を
ブロックヘッダサイズで繰り上げます。</p>

<p>また、mallocが返却するブロック本体だけではなくブロックヘッダも必要です。</p>

<p>つまり、malloc関数で必要とするブロックの大きさは</p>

<p>((引数の値) + (ブロックヘッダサイズ) - 1) / (ブロックヘッダサイズ) + 1</p>

<p>になります。</p>

<p>この大きさ以上のsizeを持つブロックをフリーブロックリストから検索します。
(前述の通りfreepの位置から検索します)</p>

<p>そして、最初に見つかった条件に合うブロックを使用します。</p>

<p>この最初に見つかったブロックを使用するを使用することを「first fit」と呼びます。</p>

<p>最初に見つかったブロックを使用するので速度的には良いのですが、メモリの空間効率としてはあまり良くありません。</p>

<p>もしかしたら、使用することに決めたブロックよりも後ろに丁度良いsizeを持つブロックがあるかもしれません。</p>

<p><img src="/images/2014_08_25/malloc_firstfit.png" alt="CPUバス" /></p>

<p>丁度良いサイズのブロックを使うようにすれば、ブロックの分割が発生し難いので、フラグメンテーションは発生し難くなるはずです。</p>

<p>この丁度良い大きさのブロックを使用するようにすることを「best fit」と呼びます。<br/>
krmallocのアルゴリズムで「best fit」を実現しようとする場合、最悪フリーブロックリストを最後まで走査した上で使用するブロックを選ぶことになるので
速度的にはよろしくありません。</p>

<p>アルゴリズムにも寄りますが、速度と空間効率は互いにトレードオフな関係になるので、krmallocでは速度優先ということで。
(まあ、特定条件下では速度的にもダメダメですが･･･)</p>

<h3>未使用ブロックが見つからない場合</h3>

<p>未使用ブロックの検索で必要な大きさ以上のsizeを持つ未使用ブロックが見つからなかった場合、
ヒープ領域から新たにmallocが管理するメモリを追加します。</p>

<p>追加するメモリサイズは</p>

<p>(必要なブロックの大きさ(ブロックヘッダサイズ単位)) * (ブロックヘッダのサイズ)</p>

<p>です。</p>

<p>ただし、前述のとおりヒープ領域からメモリを確保する際の最小サイズはNALLOCに寄ります。</p>

<p>ヒープ領域からメモリを確保するにはカーネルのシステムコールを使います。</p>

<p>K&amp;RではUNIX環境で話をしているので、sbrk関数を使っています。<br/>
(最近はmmap関数を使うのが主流になっていますが･･･)</p>

<p>WindowsだとWindowsAPIのVirtualAlloc関数を使うことになります。</p>

<p>ヒープ領域からメモリを確保したら、ブロックヘッダを付けます。
そして、そのブロックに対してfree関数を実行し、そのブロックをフリーブロックリストに組み込みます。</p>

<p>そうして、改めてmalloc関数の処理を行います。</p>

<p><img src="/images/2014_08_25/malloc_add_heap.png" alt="ヒープ領域拡張" /></p>

<h3>十分に空いたブロックがある場合</h3>

<p>フリーブロックリストの検索でヒットしたブロックのsizeが必要なブロックの大きさを十分に満たす場合(必要なブロックの大きさよりずっと大きい場合)、
ヒットしたブロックの後ろから削る形で、ブロックを取得します。</p>

<p>ヒットしたブロック内にブロックヘッダを作り、ヒットしたブロックのsizeを変更することで、ヒットしたブロックを分割します。</p>

<p>そして、分割した後ろのブロックを返却します。</p>

<p>この場合はフリーブロックリストの繋ぎなおしなどは必要ありません。</p>

<p><img src="/images/2014_08_25/malloc1.png" alt="十分に空いたブロックの場合" /></p>

<h3>サイズが丁度のブロックを使う場合</h3>

<p>フリーブロックリストの検索でヒットしたブロックのsizeが必要なブロックの大きさに合致した場合は、
ヒットしたブロックを返却します。</p>

<p>そのため、フリーブロックリストからヒットしたブロックを外す必要があります。</p>

<p>ヒットしたブロックの直前のフリーブロックのptrへヒットしたブロックのptrを設定することで、フリーブロックリストから外します。</p>

<p>そして、ヒットしたブロックを返却します。</p>

<p><img src="/images/2014_08_25/malloc2.png" alt="十分に空いたブロックの場合" /></p>

<h2>free関数</h2>

<p>free関数が呼ばれると、引数で指定されたアドレスに対して直前のブロックをフリーブロックリストから検索します。</p>

<p>前述したとおり、フリーブロックリストはブロックのアドレス順になっているので、以下のブロックが直前のブロックとなるはずです。</p>

<ul>
<li>ブロックのアドレスが対象のアドレスよりも前</li>
<li>ブロックのptrが指すブロックのアドレスが対象のアドレスよりも後</li>
</ul>


<p>そして、引数で指定されたアドレスのブロック（以降、対象のブロック）が、
ヒットしたブロック（以降、直前のブロックと呼ぶ）およびヒットしたブロックのptrが指すブロック(以降、直後のフリーブロックと呼ぶ)と
隣接しているかを確認します。</p>

<p><img src="/images/2014_08_25/near_block.png" alt="隣接するブロック判定" /></p>

<h3>隣接するフリーブロックのない場合</h3>

<p>対象のブロックと隣接するフリーブロックが存在しない場合は、対象のブロックをフリーブロックリストに組み込みます。</p>

<ul>
<li>対象のブロックのptrへ前のブロックのptrの値を設定する。</li>
<li>前のブロックのptrへ対象のブロックのアドレスを設定する。</li>
</ul>


<p>こうすることで、対象ブロックを未使用ブロックのリストへ組み込みます。</p>

<p><img src="/images/2014_08_25/free1.png" alt="隣接するブロックがない場合" /></p>

<h3>隣接するフリーブロックがある場合</h3>

<p>対象のブロックと隣接するフリーブロックが存在する場合は隣接するフリーブロックと結合します。</p>

<p>結合しておかないと、malloc関数で分割されたら分割されっぱなしで大きいサイズでmallocができなくなりますからね。</p>

<p>対象のブロックが直後のフリーブロックと隣接する場合、以下を行います。</p>

<ul>
<li>対象のブロックのprtへ、直後のフリーブロックのptrの値を設定する</li>
<li>直前のフリーブロックのptrへ、対象のブロックのアドレスを設定する</li>
<li>対象のブロックのsizeへ、直後のフリーブロックのsizeを加える</li>
</ul>


<p><img src="/images/2014_08_25/free2.png" alt="直後のブロックと隣接する場合" /></p>

<p>対象のブロックが直前のフリーブロックと隣接する場合、以下を行います。</p>

<ul>
<li>直前のブロックのsizeへ、対象のブロックのsizeを加える</li>
</ul>


<p><img src="/images/2014_08_25/free3.png" alt="直後のブロックと隣接する場合" /></p>

<p>前後両方のフリーブロックと隣接する場合は上記の両方を行います。</p>

<h2>K&amp;R mallocの良いところ</h2>

<ul>
<li><p>アルゴリズムが単純</p>

<p>  コードも100行いかないくらいです</p></li>
<li><p>それなりに早い</p>

<p>  ハードウエアキャッシュが使われやすいのも良い！</p></li>
</ul>


<h2>K&amp;R mallocの悪いところ</h2>

<ul>
<li><p>細かいサイズでmalloc関数を何度も呼ぶとフラグメンテーションが進みやすい。</p>

<p>  前述したとおり、first fitなのでフラグメンテーションが発生しやすいです。</p>

<p>  最近のプログラミング言語ではnewするたびにmallocが奔るので、細かいサイズのmalloc関数呼び出しが多発するので
  速攻でフラグメンテーションが進みます。</p></li>
<li><p>フリーブロックリストの検索が遅いときは凄い遅い。</p>

<p>  brk関数が呼ばれる状況では必ずフリーブロックリストを必ず一周しなくてはいけない。<br/>
  freepの直前のブロックしか使える未使用ブロックがなかったりするとフリーブロックリストをほぼ一周してしまう。</p></li>
<li><p>そもそも、マルチスレッド対応してないじゃん。</p>

<p>  K&amp;R出版当時はマルチスレッドありませんしね･･･</p></li>
</ul>


<p>よく使われているmallocアルゴリズムでは、このあたりを改善しています。<br/>
興味があったらglibcのmallocなどを読んでみると良いと思います。
(すげえ長いですが･･･)<br/>
glibcはgithubにも置いてあるので読みやすいと思います。</p>

<h1>最後に</h1>

<p>malloc関数でのメモリ管理ではkrmallocに限らずどのアルゴリズムでも、メモリ管理用の情報分のメモリを消費しますし、
速度や空間効率が極端に悪くなる状況があったりします。</p>

<p>ライブラリのmalloc関数は一般的なアプリケーション向けにチューニングしたアルゴリズムを使うので、
高速で実行したいプログラムや大量にメモリを消費するプログラムなどだと、ここがボトルネックになる場合もあります。</p>

<p>そういう場合は、アプリケーションが独自でメモリ管理を行った方が良いかもしれません。
ライブラリのアルゴリズムはあんまり信用しすぎない方が良いのです。</p>
]]></content>
  </entry>
  
</feed>
