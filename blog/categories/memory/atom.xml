<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Memory | らじうむ覚書]]></title>
  <link href="http://radlon.github.io/blog/categories/memory/atom.xml" rel="self"/>
  <link href="http://radlon.github.io/"/>
  <updated>2014-08-25T23:16:16+09:00</updated>
  <id>http://radlon.github.io/</id>
  <author>
    <name><![CDATA[radlon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[K&R Malloc解説]]></title>
    <link href="http://radlon.github.io/blog/2014/08/25/krmalloc/"/>
    <updated>2014-08-25T23:00:00+09:00</updated>
    <id>http://radlon.github.io/blog/2014/08/25/krmalloc</id>
    <content type="html"><![CDATA[<p>なにか、無闇に時間掛かってしまった･･･</p>

<p>後で見直して直すと思います。</p>

<p>数あるmallocアルゴリズムの基本であるK&amp;Rのmallocアルゴリズムを解説いたします。</p>

<!-- more -->


<p>K&amp;Rとは初期のC言語を解説した書籍「プログラミング言語C」(原題:The Programing Language)のことです。</p>

<p>著者であるブライアン・カーニハン氏(Brian W. Kernighan)とデニス・リッチー氏(Dennis M. Ritchie)の頭文字をとってK&amp;Rと呼ばれています。</p>

<p>malloc関数とはヒープ領域から、指定したサイズのメモリを動的に確保する関数です。<br/>
C言語などの低レベルの処理を記述する言語では馴染みのある関数です。<br/>
Javaなど低レベルの処理を記述しない言語しか使用していない人には、あまり馴染みがないでしょうか？</p>

<p>malloc関数で確保したメモリは対応するfree関数で解放いたします。<br/>
明示的にメモリを解放しなければ解放されることはありません。<br/>
もちろん、ここで確保されるのは仮想メモリ空間のメモリですので、
基本的にはプロセスが終了する際に解放されます。</p>

<h1>データ構造</h1>

<p>krmallocではメモリをブロック単位で管理します。<br/>
ブロックは以下の構造をしています。</p>

<p><img src="/images/2014_08_25/data_struct.png" alt="データ構造" /></p>

<ul>
<li><p>ブロックヘッダ</p>

<ul>
<li><p>ブロック情報</p>

<ul>
<li><p>ptr</p>

<p>  次のブロックへのポインタ</p></li>
<li><p>size</p>

<p>  ブロック全体(ブロックヘッダとブロック本体)のサイズ。<br/>
  このsizeはバイト数ではなくブロックヘッダを１単位としたサイズです。</p></li>
</ul>
</li>
<li><p>アライメント調整値(Align)</p></li>
</ul>
</li>
<li><p>ブロック本体</p>

<p>  mallocで返却し、呼び出し元が使用するメモリ。<br/>
  ブロック本体のサイズはブロックヘッダのサイズの倍数とします。</p></li>
</ul>


<p>krmallocではブロックヘッダのサイズを１単位としてメモリを管理します。</p>

<p>mallocで要求されたサイズがブロックヘッダサイズ以下であってもブロックヘッダサイズで割り当てます。</p>

<p>ブロックヘッダサイズ単位でメモリを管理するのは、後述するmallocのアルゴリズムでブロックを分割・結合を行う処理があるためです。</p>

<p>現在未使用のブロックはptrによりリング状の一方向リストとします。</p>

<p><img src="/images/2014_08_25/example_list.png" alt="データ構造のリスト" /></p>

<p>図のbaseはsizeが0のブロック本体を持たないブロックで、グローバル変数として定義します。</p>

<p>未使用ブロックが存在しない場合、未使用ブロックのリストはこのbaseのみを持つ形になります。</p>

<p>このリストのブロックの並び順は、図のようにブロックのアドレスが前後しない順序を維持します。</p>

<p>こうすることで、対象のブロックの前後に未使用ブロックが隣接するかを判断し易くします。</p>

<p>(リストの順がバラバラだとリストを一周しないと前後の未使用ブロックが判別できません)</p>

<p>krmallocではこのリストから、要求されたサイズのブロックを外して返却する形になります。</p>

<p>また、free関数で指定されたブロックは、このリストへ組み込み、次回以降のmalloc呼び出し時に返却する対象にします。</p>

<h2>アライメント</h2>

<p>先ほどのアライメントを合わせるという言葉が出ましたが、
アライメントという言葉を覚えているでしょうか？</p>

<p>CPUとメモリは複数本のバスで繋がっています。メモリを読み込む場合このバスの本数分の範囲をパラレルに読み込みます。</p>

<p><img src="/images/2014_08_25/cpu_databus.png" alt="CPUバス" /></p>

<p>CPUは上記の図のようにしてメモリを読み込みます。</p>

<p>メモリ上の値はそのサイズにより決まった区切りに収まる形で配置します。</p>

<p>1byteの値を図のbyteのマス２つに跨がって配置することはできません。必ず1マスに納めます。</p>

<p>メモリ上に区切り位置を跨がった形で値を配置した場合、エラーが発生します。</p>

<p>この区切りをアライメントと呼びます。</p>

<p>C言語において、構造体および共用体のアライメントはメンバのうちの最もアライメントの制限が厳しい型のアライメントが適用されます。</p>

<p>構造体のサイズがメンバのサイズの合計とならないのはこのためです。</p>

<p>mallocで返却したメモリはあらゆる型で使用します。
そのため、ブロックヘッダにアライメント調整値としてあらゆる型で最もアライメントの制限が厳しい型を使用します。</p>

<p>ここでいう最もアライメントの制限が厳しい型というのは、プログラミング言語の言語仕様ではなく、
CPUの仕様に依存します。</p>

<p>そうすることで、ブロック本体の位置があらゆる型のアライメントにあった位置となります。</p>

<p>ちなみに、このようにアライメントを合わせるため、mallocが返却するアドレスの下位数ビットは必ず0になります。</p>

<p>glibcのdlmallocでは、このことを利用してptrの値の下位数ビットをフラグとして利用しています。</p>

<h1>アルゴリズム</h1>

<h2>malloc</h2>

<p>mallocが呼ばれると、まずmallocが要求するサイズで使用するブロックのsizeを算出します。</p>

<p>前述の通りkrmallocではブロックヘッダのサイズを１単位としてメモリを管理しています。</p>

<p>そのため、ブロック本体のサイズはブロックヘッダサイズで繰り上げた値となります。</p>

<p>また、mallocが返却するブロック本体だけではなくブロックヘッダも必要です。</p>

<p>つまり、mallocが返却するブロックのsizeは以下になります。</p>

<p>((mallocで要求されたサイズ) + (ブロックヘッダサイズ) - 1) / (ブロックヘッダサイズ) + 1</p>

<p>このsize以上のsizeを持つブロックを未使用ブロックのリストからfreepの位置を始点にして探します。</p>

<p>そして、最初に見つかった条件に合うsizeを持つ未使用ブロックを使用します。</p>

<p>この最初に見つかった未使用ブロックを使用するを使用することを「first fit」と呼びます。</p>

<p><img src="/images/2014_08_25/malloc1.png" alt="malloc1" /></p>

<h3>未使用ブロックが見つからない場合</h3>

<p>条件に合うsizeの未使用ブロックが見つからなかった場合、
ヒープ領域から新たにmallocが管理するメモリを追加します。</p>

<p>追加するメモリサイズは</p>

<p>(mallocが返却するブロックのsize) * (ブロックヘッダのサイズ)</p>

<p>です。</p>

<p>ただし、sizeが要求最小size(K&amp;Rでは1024)未満の場合は、この最小sizeを追加します。</p>

<p>メモリを確保するには、カーネルへヒープ領域から新たにメモリを確保するように要求します。
この処理にはそれなりのコストがかかります。<br/>
細かいサイズを連続して確保するのは効率が良くありません。<br/>
なのでmallocで要求されたサイズが小さかったとしても、
ある程度のサイズのメモリを確保するようにします。</p>

<p>確保したメモリは、ブロックヘッダを付けた上で、そのブロックに対してfreeを実行します。</p>

<p>これにより、確保したメモリのブロックは未使用ブロックのリストへ組み込まれます。</p>

<p><img src="/images/2014_08_25/malloc2.png" alt="malloc2" /></p>

<p>そして、改めてmallocの処理を実行します。</p>

<h3>十分に空いたブロックがある場合</h3>

<p>未使用ブロックのリストを探索した結果、sizeに「(mallocの呼び出し元から要求されたサイズ)+(ブロックヘッダのサイズ)」以上を
持つブロックが見つかった場合、見つかったブロックの後方から必要なサイズのブロックを削り出す形でブロックを取得します。</p>

<p>この場合、未使用ブロックのリストの組み替えは必要ありません。</p>

<p>削り出したブロックへブロックヘッダを書き込み、
使用した未使用ブロックのsizeのみ更新します。</p>

<p><img src="/images/2014_08_25/malloc3.png" alt="malloc3" /></p>

<p>そして、mallocの呼び出しもとへ削りだしたブロックのブロック本体のアドレスを返却します。</p>

<h3>サイズが丁度のブロックを使う場合</h3>

<p>未使用ブロックのリストを探索した結果、sizeに「(mallocの呼び出し元から要求されたサイズ)」以上、「(mallocの呼び出し元から要求されたサイズ)+(ブロックヘッダのサイズ)」未満を
持つブロックが見つかった場合、
見つかったブロックを未使用ブロックのリストから外します。</p>

<p>前のブロックのヘッダーのptrをヒットしたブロックのptrへ書き換えることで、ヒットしたブロックを
未使用ブロックのリストから外します。</p>

<p><img src="/images/2014_08_25/malloc4.png" alt="malloc4" /></p>

<p>そして、mallocの呼び出し元へ見つかったブロックのブロック本体のアドレスを返却します。</p>

<h2>free</h2>

<p>freeが呼ばれると、freeで指定されたブロックに対してリニアアドレス上で直前の未使用ブロックを、
未使用ブロックのリストから検索します。</p>

<p>未使用ブロックのリストのブロックの順序はリニアアドレス上のアドレスの順で維持しているので、
freeで指定されたブロックのアドレスと比較することで、検索が可能です。</p>

<p>ちなみに、この検索でもfreepを始点とします。</p>

<p>そして、みつけた未使用のブロックおよび未使用のブロックのptrが示す次のブロックが、対象のブロックと隣接しているかを確認します。</p>

<h3>隣接する未使用ブロックのない場合</h3>

<p>隣接する未使用ブロックが存在しない場合、freeが指定したブロックを未使用ブロックのリストへ組み込みます。</p>

<ul>
<li>対象のブロックのptrへ前のブロックのptrの値を設定する。</li>
<li>前のブロックのptrへ対象のブロックのアドレスを設定する。</li>
</ul>


<p>これにより、対象ブロックを未使用ブロックのリストへ組み込みます。</p>

<p><img src="/images/2014_08_25/free1.png" alt="free1" /></p>

<h3>隣接する未使用ブロックがある場合</h3>

<p>対象のブロックに隣接する未使用のブロックがある場合は、
対象のブロックと未使用のブロックを結合します。</p>

<p>対象のブロックを後ろのブロックと結合する場合、以下を行います。</p>

<ul>
<li>対象のブロックのprtへ後ろのブロックのptrの値を設定する</li>
<li>対象のブロックのsizeへ「後のブロックのsize」を加える</li>
</ul>


<p>対象のブロックを前のブロックと結合する場合、以下を行います。</p>

<ul>
<li>前のブロックのptrへ対象のブロックのptrの値を設定する。(後ろのブロックと結合していない場合は変更しない)</li>
<li>前のブロックのsizeへ「対象のブロックのsize」を加える</li>
</ul>


<p><img src="/images/2014_08_25/free2.png" alt="free2" /></p>

<h2>freepとはなんだったのか？</h2>

<p>freepはmallocを行った場合は返却したブロックの直前の未使用ブロック、
freeを行った場合は解放したブロックに移動します。</p>

<p>このようにして検索開始位置を移動するのは、使用するブロックに偏りを持たせないため
･･･ということになっています。</p>

<p>毎回先頭から未使用ブロックを検索したのでは、後ろの方にある大きな未使用ブロックが使われ難くなり、
前の方の小さなブロックばかりが使われ易なります。</p>

<p>大きな未使用ブロックから必要なサイズを削るだけ(未使用ブロックのsizeを変更するのみ）の方が、
未使用ブロックのリストをつなぎ直すよりも楽であるため、このようにしているとなっています。</p>

<p>しかし、実際のところfreepを使用することは、上記とは別の大きな効果に繋がっています。</p>

<p>たいていのプロセスは</p>

<p>メモリ確保>メモリ解放>メモリ確保>メモリ解放>…</p>

<p>のように、
確保したメモリをすぐに解放しています。</p>

<p>また、mallocした直後とfreeする直前に対象のメモリへアクセスを行うことが多いと思います。</p>

<p>(malloc直後は初期化のため、freeは不要になったときなので直前に使っていることが多いはず)</p>

<p>そのため、freeしたアドレス付近のメモリはハードキャッシュに乗っている確率が非常に多いです。</p>

<p>そして、malloc直後にアクセスするので、mallocした時点でハードキャッシュに載っていることは、非常に有利です。</p>

<p>freepを使用すると、直前にfreeしたメモリを優先的にmallocで使うことになるため、ハードキャッシュに乗ったメモリが使われ易い
ので非常に良いということです。</p>

<h2>フラグメンテーション</h2>

<p>krmallocではfirst fitで使用するブロックを決定します。</p>

<p>要求したサイズに丁度良いサイズの未使用ブロックがあったとしても、
大きなブロックを削ってメモリ確保をすることになりやすいため、
リニアなメモリ空間上に細かい空きが出来易くなります。</p>

<p>これにより、空いているメモリサイズの総量は十分にあるのにメモリを確保出来ないという状態が発生します</p>

<p>これを「フラグメンテーション」と呼びます。</p>

<p><img src="/images/2014_08_25/fragment.png" alt="フラグメンテーション" /></p>

<p>とはいえ、krmallocのアルゴリズムではbest fitとなるブロックを検索するというのは
コストが掛かりすぎます。</p>

<p>(最悪、全未使用ブロックを走査することになる)</p>

<p>glibcのdlmallocアルゴリズムでは、未使用ブロックをサイズ毎に管理するbins配列を使用することでbest fitを実現しています。</p>

<h1>最後に</h1>

<p>mallocでメモリを確保する場合、解説したようにブロックヘッダ分のメモリを消費したり、
メモリ管理のための処理など、アプリケーション作成者の意図しないコストが掛かります。</p>

<p>もしかしたら、アプリケーション作者が自力でメモリ管理を行った方が良いかもしれません。</p>

<p>普段はあまり意識しないかもしれませんが、アプリケーションの高速化または軽量化を行う場合は
このあたりに立ち返って設計を行うと良いと思いますよ。</p>
]]></content>
  </entry>
  
</feed>
